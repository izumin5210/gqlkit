import { describe, expect, it } from "vitest";
import type {
  AutoGeneratedType,
  GeneratedFromInfo,
} from "./auto-type-generator.js";
import {
  type NameCollisionValidatorInput,
  validateNameCollisions,
} from "./name-collision-validator.js";

function createMockAutoGeneratedType(
  name: string,
  generatedFrom: GeneratedFromInfo,
  sourceFile = "src/gqlkit/schema/types.ts",
  line = 1,
): AutoGeneratedType {
  return {
    name,
    kind: "Object",
    fields: [],
    sourceLocation: { file: sourceFile, line, column: 1 },
    generatedFrom,
    description: null,
  };
}

describe("validateNameCollisions", () => {
  describe("user-defined type collision detection", () => {
    it("detects collision between auto-generated type and user-defined type", () => {
      const input: NameCollisionValidatorInput = {
        userDefinedTypes: [
          {
            name: "UserProfile",
            sourceLocation: {
              file: "src/gqlkit/schema/user.ts",
              line: 10,
              column: 1,
            },
          },
        ],
        autoGeneratedTypes: [
          createMockAutoGeneratedType(
            "UserProfile",
            {
              parentTypeName: "User",
              fieldPath: ["profile"],
              context: "typeField",
            },
            "src/gqlkit/schema/types.ts",
            5,
          ),
        ],
      };

      const result = validateNameCollisions(input);

      expect(result.hasCollisions).toBe(true);
      expect(result.diagnostics).toHaveLength(1);
      expect(result.diagnostics[0]).toMatchObject({
        code: "AUTO_TYPE_NAME_COLLISION_USER",
        severity: "error",
      });
      expect(result.diagnostics[0]?.message).toContain("UserProfile");
      expect(result.diagnostics[0]?.message).toContain("user-defined type");
    });

    it("includes source locations in diagnostic message", () => {
      const input: NameCollisionValidatorInput = {
        userDefinedTypes: [
          {
            name: "UserProfile",
            sourceLocation: {
              file: "src/gqlkit/schema/user.ts",
              line: 10,
              column: 1,
            },
          },
        ],
        autoGeneratedTypes: [
          createMockAutoGeneratedType(
            "UserProfile",
            {
              parentTypeName: "User",
              fieldPath: ["profile"],
              context: "typeField",
            },
            "src/gqlkit/schema/types.ts",
            5,
          ),
        ],
      };

      const result = validateNameCollisions(input);

      expect(result.diagnostics[0]?.message).toContain(
        "src/gqlkit/schema/user.ts",
      );
    });

    it("includes recommended resolution in diagnostic message", () => {
      const input: NameCollisionValidatorInput = {
        userDefinedTypes: [
          {
            name: "UserProfile",
            sourceLocation: {
              file: "src/gqlkit/schema/user.ts",
              line: 10,
              column: 1,
            },
          },
        ],
        autoGeneratedTypes: [
          createMockAutoGeneratedType("UserProfile", {
            parentTypeName: "User",
            fieldPath: ["profile"],
            context: "typeField",
          }),
        ],
      };

      const result = validateNameCollisions(input);

      const message = result.diagnostics[0]?.message ?? "";
      expect(
        message.includes("renaming") || message.includes("explicit type"),
      ).toBe(true);
    });

    it("returns no collisions when types do not conflict", () => {
      const input: NameCollisionValidatorInput = {
        userDefinedTypes: [
          {
            name: "User",
            sourceLocation: {
              file: "src/gqlkit/schema/user.ts",
              line: 10,
              column: 1,
            },
          },
        ],
        autoGeneratedTypes: [
          createMockAutoGeneratedType("UserProfile", {
            parentTypeName: "User",
            fieldPath: ["profile"],
            context: "typeField",
          }),
        ],
      };

      const result = validateNameCollisions(input);

      expect(result.hasCollisions).toBe(false);
      expect(result.diagnostics).toHaveLength(0);
    });

    it("detects multiple user-defined type collisions", () => {
      const input: NameCollisionValidatorInput = {
        userDefinedTypes: [
          {
            name: "UserProfile",
            sourceLocation: {
              file: "src/gqlkit/schema/user.ts",
              line: 10,
              column: 1,
            },
          },
          {
            name: "UserAddress",
            sourceLocation: {
              file: "src/gqlkit/schema/user.ts",
              line: 20,
              column: 1,
            },
          },
        ],
        autoGeneratedTypes: [
          createMockAutoGeneratedType("UserProfile", {
            parentTypeName: "User",
            fieldPath: ["profile"],
            context: "typeField",
          }),
          createMockAutoGeneratedType("UserAddress", {
            parentTypeName: "User",
            fieldPath: ["address"],
            context: "typeField",
          }),
        ],
      };

      const result = validateNameCollisions(input);

      expect(result.hasCollisions).toBe(true);
      expect(result.diagnostics).toHaveLength(2);
      expect(
        result.diagnostics.every(
          (d) => d.code === "AUTO_TYPE_NAME_COLLISION_USER",
        ),
      ).toBe(true);
    });
  });

  describe("auto-generated type collision detection", () => {
    it("detects collision between multiple auto-generated types with same name", () => {
      const input: NameCollisionValidatorInput = {
        userDefinedTypes: [],
        autoGeneratedTypes: [
          createMockAutoGeneratedType(
            "UpdateDataInput",
            {
              parentTypeName: null,
              fieldPath: ["data"],
              context: "resolverArg",
            },
            "src/gqlkit/schema/mutation.ts",
            5,
          ),
          createMockAutoGeneratedType(
            "UpdateDataInput",
            {
              parentTypeName: null,
              fieldPath: ["data"],
              context: "resolverArg",
            },
            "src/gqlkit/schema/query.ts",
            10,
          ),
        ],
      };

      const result = validateNameCollisions(input);

      expect(result.hasCollisions).toBe(true);
      expect(result.diagnostics).toHaveLength(1);
      expect(result.diagnostics[0]).toMatchObject({
        code: "AUTO_TYPE_NAME_COLLISION_AUTO",
        severity: "error",
      });
    });

    it("lists all collision source locations in diagnostic message", () => {
      const input: NameCollisionValidatorInput = {
        userDefinedTypes: [],
        autoGeneratedTypes: [
          createMockAutoGeneratedType(
            "UpdateDataInput",
            {
              parentTypeName: null,
              fieldPath: ["data"],
              context: "resolverArg",
            },
            "src/gqlkit/schema/mutation.ts",
            5,
          ),
          createMockAutoGeneratedType(
            "UpdateDataInput",
            {
              parentTypeName: null,
              fieldPath: ["data"],
              context: "resolverArg",
            },
            "src/gqlkit/schema/query.ts",
            10,
          ),
        ],
      };

      const result = validateNameCollisions(input);

      const message = result.diagnostics[0]?.message ?? "";
      expect(message).toContain("src/gqlkit/schema/mutation.ts");
      expect(message).toContain("src/gqlkit/schema/query.ts");
    });

    it("includes recommended resolution in auto-collision diagnostic", () => {
      const input: NameCollisionValidatorInput = {
        userDefinedTypes: [],
        autoGeneratedTypes: [
          createMockAutoGeneratedType(
            "UpdateDataInput",
            {
              parentTypeName: null,
              fieldPath: ["data"],
              context: "resolverArg",
            },
            "src/gqlkit/schema/mutation.ts",
            5,
          ),
          createMockAutoGeneratedType(
            "UpdateDataInput",
            {
              parentTypeName: null,
              fieldPath: ["data"],
              context: "resolverArg",
            },
            "src/gqlkit/schema/query.ts",
            10,
          ),
        ],
      };

      const result = validateNameCollisions(input);

      const message = result.diagnostics[0]?.message ?? "";
      expect(message.includes("explicit type")).toBe(true);
    });

    it("returns no collisions when auto-generated types have unique names", () => {
      const input: NameCollisionValidatorInput = {
        userDefinedTypes: [],
        autoGeneratedTypes: [
          createMockAutoGeneratedType("UserProfile", {
            parentTypeName: "User",
            fieldPath: ["profile"],
            context: "typeField",
          }),
          createMockAutoGeneratedType("UserAddress", {
            parentTypeName: "User",
            fieldPath: ["address"],
            context: "typeField",
          }),
        ],
      };

      const result = validateNameCollisions(input);

      expect(result.hasCollisions).toBe(false);
      expect(result.diagnostics).toHaveLength(0);
    });

    it("handles three or more auto-generated types with same name", () => {
      const input: NameCollisionValidatorInput = {
        userDefinedTypes: [],
        autoGeneratedTypes: [
          createMockAutoGeneratedType(
            "DataInput",
            {
              parentTypeName: null,
              fieldPath: [],
              context: "resolverArg",
            },
            "src/gqlkit/schema/a.ts",
            1,
          ),
          createMockAutoGeneratedType(
            "DataInput",
            {
              parentTypeName: null,
              fieldPath: [],
              context: "resolverArg",
            },
            "src/gqlkit/schema/b.ts",
            2,
          ),
          createMockAutoGeneratedType(
            "DataInput",
            {
              parentTypeName: null,
              fieldPath: [],
              context: "resolverArg",
            },
            "src/gqlkit/schema/c.ts",
            3,
          ),
        ],
      };

      const result = validateNameCollisions(input);

      expect(result.hasCollisions).toBe(true);
      expect(result.diagnostics).toHaveLength(1);
      const message = result.diagnostics[0]?.message ?? "";
      expect(message).toContain("src/gqlkit/schema/a.ts");
      expect(message).toContain("src/gqlkit/schema/b.ts");
      expect(message).toContain("src/gqlkit/schema/c.ts");
    });
  });

  describe("combined collision scenarios", () => {
    it("detects both user-defined and auto-generated collisions", () => {
      const input: NameCollisionValidatorInput = {
        userDefinedTypes: [
          {
            name: "UserProfile",
            sourceLocation: {
              file: "src/gqlkit/schema/user.ts",
              line: 10,
              column: 1,
            },
          },
        ],
        autoGeneratedTypes: [
          createMockAutoGeneratedType("UserProfile", {
            parentTypeName: "User",
            fieldPath: ["profile"],
            context: "typeField",
          }),
          createMockAutoGeneratedType(
            "DataInput",
            {
              parentTypeName: null,
              fieldPath: [],
              context: "resolverArg",
            },
            "src/gqlkit/schema/a.ts",
            1,
          ),
          createMockAutoGeneratedType(
            "DataInput",
            {
              parentTypeName: null,
              fieldPath: [],
              context: "resolverArg",
            },
            "src/gqlkit/schema/b.ts",
            2,
          ),
        ],
      };

      const result = validateNameCollisions(input);

      expect(result.hasCollisions).toBe(true);
      expect(result.diagnostics).toHaveLength(2);
      expect(
        result.diagnostics.some(
          (d) => d.code === "AUTO_TYPE_NAME_COLLISION_USER",
        ),
      ).toBe(true);
      expect(
        result.diagnostics.some(
          (d) => d.code === "AUTO_TYPE_NAME_COLLISION_AUTO",
        ),
      ).toBe(true);
    });
  });

  describe("edge cases", () => {
    it("handles empty inputs", () => {
      const input: NameCollisionValidatorInput = {
        userDefinedTypes: [],
        autoGeneratedTypes: [],
      };

      const result = validateNameCollisions(input);

      expect(result.hasCollisions).toBe(false);
      expect(result.diagnostics).toHaveLength(0);
    });

    it("is case-sensitive for type names", () => {
      const input: NameCollisionValidatorInput = {
        userDefinedTypes: [
          {
            name: "UserProfile",
            sourceLocation: {
              file: "src/gqlkit/schema/user.ts",
              line: 10,
              column: 1,
            },
          },
        ],
        autoGeneratedTypes: [
          createMockAutoGeneratedType("Userprofile", {
            parentTypeName: "User",
            fieldPath: ["profile"],
            context: "typeField",
          }),
        ],
      };

      const result = validateNameCollisions(input);

      expect(result.hasCollisions).toBe(false);
      expect(result.diagnostics).toHaveLength(0);
    });
  });
});
