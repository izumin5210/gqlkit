import { relative } from "node:path";
import type {
  Diagnostic,
  SourceLocation,
} from "../type-extractor/types/index.js";
import type { AutoGeneratedType } from "./auto-type-generator.js";

export interface UserDefinedTypeInfo {
  readonly name: string;
  readonly sourceLocation: SourceLocation;
}

export interface NameCollisionValidatorInput {
  readonly userDefinedTypes: ReadonlyArray<UserDefinedTypeInfo>;
  readonly autoGeneratedTypes: ReadonlyArray<AutoGeneratedType>;
  readonly sourceRoot: string | null;
}

export interface NameCollisionValidatorResult {
  readonly hasCollisions: boolean;
  readonly diagnostics: ReadonlyArray<Diagnostic>;
}

function formatLocation(
  loc: SourceLocation,
  sourceRoot: string | null,
): string {
  let filePath = loc.file;
  if (sourceRoot !== null) {
    filePath = relative(sourceRoot, filePath);
  }
  const normalizedPath = filePath.replaceAll("\\", "/");
  return `${normalizedPath}:${loc.line}`;
}

function findUserDefinedCollisions(
  userDefinedTypes: ReadonlyArray<UserDefinedTypeInfo>,
  autoGeneratedTypes: ReadonlyArray<AutoGeneratedType>,
  sourceRoot: string | null,
): Diagnostic[] {
  const diagnostics: Diagnostic[] = [];

  const userTypeMap = new Map<string, UserDefinedTypeInfo>();
  for (const userType of userDefinedTypes) {
    userTypeMap.set(userType.name, userType);
  }

  for (const autoType of autoGeneratedTypes) {
    const userType = userTypeMap.get(autoType.name);
    if (userType) {
      diagnostics.push({
        code: "AUTO_TYPE_NAME_COLLISION_USER",
        message: `Auto-generated type '${autoType.name}' conflicts with user-defined type at ${formatLocation(userType.sourceLocation, sourceRoot)}. Consider renaming the field or using an explicit type definition.`,
        severity: "error",
        location: autoType.sourceLocation,
      });
    }
  }

  return diagnostics;
}

function findAutoGeneratedCollisions(
  autoGeneratedTypes: ReadonlyArray<AutoGeneratedType>,
  sourceRoot: string | null,
): Diagnostic[] {
  const diagnostics: Diagnostic[] = [];

  const typesByName = new Map<string, AutoGeneratedType[]>();
  for (const autoType of autoGeneratedTypes) {
    const existing = typesByName.get(autoType.name);
    if (existing) {
      existing.push(autoType);
    } else {
      typesByName.set(autoType.name, [autoType]);
    }
  }

  for (const [name, types] of typesByName) {
    if (types.length > 1) {
      const locations = types
        .map((t) => formatLocation(t.sourceLocation, sourceRoot))
        .join(", ");
      const firstType = types[0];
      if (firstType) {
        diagnostics.push({
          code: "AUTO_TYPE_NAME_COLLISION_AUTO",
          message: `Auto-generated type name '${name}' is generated from multiple sources: ${locations}. Use explicit type definitions to resolve the conflict.`,
          severity: "error",
          location: firstType.sourceLocation,
        });
      }
    }
  }

  return diagnostics;
}

export function validateNameCollisions(
  input: NameCollisionValidatorInput,
): NameCollisionValidatorResult {
  const userCollisions = findUserDefinedCollisions(
    input.userDefinedTypes,
    input.autoGeneratedTypes,
    input.sourceRoot,
  );

  const autoCollisions = findAutoGeneratedCollisions(
    input.autoGeneratedTypes,
    input.sourceRoot,
  );

  const diagnostics = [...userCollisions, ...autoCollisions];

  return {
    hasCollisions: diagnostics.length > 0,
    diagnostics,
  };
}
