import { describe, expect, it } from "vitest";
import type {
  ExtractResolversResult,
  GraphQLInputValue,
} from "../resolver-extractor/index.js";
import type {
  ExtractedTypeInfo,
  FieldDefinition,
  InlineObjectPropertyDef,
  TSTypeReference,
} from "../type-extractor/types/index.js";
import {
  type AutoTypeGeneratorInput,
  generateAutoTypes,
} from "./auto-type-generator.js";

function createInlineObjectTsType(
  properties: InlineObjectPropertyDef[],
  nullable = false,
): TSTypeReference {
  return {
    kind: "inlineObject",
    name: null,
    elementType: null,
    members: null,
    nullable,
    scalarInfo: null,
    inlineObjectProperties: properties,
  };
}

function createPrimitiveTsType(
  name: string,
  nullable = false,
): TSTypeReference {
  return {
    kind: "primitive",
    name,
    elementType: null,
    members: null,
    nullable,
    scalarInfo: null,
    inlineObjectProperties: null,
  };
}

function createProperty(
  name: string,
  tsType: TSTypeReference,
  optional = false,
  description: string | null = null,
): InlineObjectPropertyDef {
  return {
    name,
    tsType,
    optional,
    description,
    deprecated: null,
    directives: null,
    defaultValue: null,
  };
}

function createField(
  name: string,
  tsType: TSTypeReference,
  optional = false,
  description: string | null = null,
): FieldDefinition {
  return {
    name,
    tsType,
    optional,
    description,
    deprecated: null,
    directives: null,
    defaultValue: null,
  };
}

function createExtractedType(
  name: string,
  fields: FieldDefinition[],
  kind: "object" | "interface" = "object",
): ExtractedTypeInfo {
  return {
    metadata: {
      name,
      kind,
      sourceFile: "src/gqlkit/schema/types.ts",
      exportKind: "named",
      description: null,
      deprecated: null,
      directives: null,
    },
    fields,
    unionMembers: null,
    inlineObjectMembers: null,
    enumMembers: null,
    implementedInterfaces: null,
  };
}

function createEmptyResolversResult(): ExtractResolversResult {
  return {
    queryFields: { fields: [] },
    mutationFields: { fields: [] },
    typeExtensions: [],
    diagnostics: { errors: [], warnings: [] },
  };
}

describe("generateAutoTypes", () => {
  describe("Object type field inline objects", () => {
    it("generates Object type from inline object in Object type field", () => {
      const inlineProperties: InlineObjectPropertyDef[] = [
        createProperty("bio", createPrimitiveTsType("string")),
        createProperty("website", createPrimitiveTsType("string", true)),
      ];

      const extractedTypes: ExtractedTypeInfo[] = [
        createExtractedType("User", [
          createField("id", createPrimitiveTsType("string")),
          createField("profile", createInlineObjectTsType(inlineProperties)),
        ]),
      ];

      const input: AutoTypeGeneratorInput = {
        extractedTypes,
        resolversResult: createEmptyResolversResult(),
      };

      const result = generateAutoTypes(input);

      expect(result.autoGeneratedTypes).toHaveLength(1);

      const autoType = result.autoGeneratedTypes[0]!;
      expect(autoType.name).toBe("UserProfile");
      expect(autoType.kind).toBe("Object");
      expect(autoType.fields).toHaveLength(2);
      expect(autoType.fields.map((f) => f.name)).toEqual(["bio", "website"]);
      expect(autoType.generatedFrom).toEqual({
        parentTypeName: "User",
        fieldPath: ["profile"],
        context: "typeField",
      });
    });

    it("generates nested Object types recursively", () => {
      const locationProperties: InlineObjectPropertyDef[] = [
        createProperty("latitude", createPrimitiveTsType("number")),
        createProperty("longitude", createPrimitiveTsType("number")),
      ];

      const addressProperties: InlineObjectPropertyDef[] = [
        createProperty("street", createPrimitiveTsType("string")),
        createProperty(
          "location",
          createInlineObjectTsType(locationProperties),
        ),
      ];

      const profileProperties: InlineObjectPropertyDef[] = [
        createProperty("bio", createPrimitiveTsType("string")),
        createProperty("address", createInlineObjectTsType(addressProperties)),
      ];

      const extractedTypes: ExtractedTypeInfo[] = [
        createExtractedType("User", [
          createField("id", createPrimitiveTsType("string")),
          createField("profile", createInlineObjectTsType(profileProperties)),
        ]),
      ];

      const input: AutoTypeGeneratorInput = {
        extractedTypes,
        resolversResult: createEmptyResolversResult(),
      };

      const result = generateAutoTypes(input);

      expect(result.autoGeneratedTypes).toHaveLength(3);

      const typeNames = result.autoGeneratedTypes.map((t) => t.name).sort();
      expect(typeNames).toEqual([
        "UserProfile",
        "UserProfileAddress",
        "UserProfileAddressLocation",
      ]);
    });

    it("preserves description from inline object properties", () => {
      const inlineProperties: InlineObjectPropertyDef[] = [
        createProperty(
          "bio",
          createPrimitiveTsType("string"),
          false,
          "User biography",
        ),
      ];

      const extractedTypes: ExtractedTypeInfo[] = [
        createExtractedType("User", [
          createField(
            "profile",
            createInlineObjectTsType(inlineProperties),
            false,
            "Profile information",
          ),
        ]),
      ];

      const input: AutoTypeGeneratorInput = {
        extractedTypes,
        resolversResult: createEmptyResolversResult(),
      };

      const result = generateAutoTypes(input);

      expect(result.autoGeneratedTypes).toHaveLength(1);
      const autoType = result.autoGeneratedTypes[0]!;
      expect(autoType.fields[0]!.description).toBe("User biography");
    });
  });

  describe("Input type field inline objects", () => {
    it("generates Input Object type from inline object in Input type field", () => {
      const inlineProperties: InlineObjectPropertyDef[] = [
        createProperty("bio", createPrimitiveTsType("string", true)),
        createProperty("age", createPrimitiveTsType("number")),
      ];

      const extractedTypes: ExtractedTypeInfo[] = [
        createExtractedType("CreateUserInput", [
          createField("name", createPrimitiveTsType("string")),
          createField("profile", createInlineObjectTsType(inlineProperties)),
        ]),
      ];

      const input: AutoTypeGeneratorInput = {
        extractedTypes,
        resolversResult: createEmptyResolversResult(),
      };

      const result = generateAutoTypes(input);

      expect(result.autoGeneratedTypes).toHaveLength(1);

      const autoType = result.autoGeneratedTypes[0]!;
      expect(autoType.name).toBe("CreateUserProfileInput");
      expect(autoType.kind).toBe("InputObject");
      expect(autoType.generatedFrom.context).toBe("inputField");
    });

    it("generates nested Input Object types with correct naming", () => {
      const addressProperties: InlineObjectPropertyDef[] = [
        createProperty("street", createPrimitiveTsType("string")),
        createProperty("city", createPrimitiveTsType("string")),
      ];

      const profileProperties: InlineObjectPropertyDef[] = [
        createProperty("bio", createPrimitiveTsType("string", true)),
        createProperty(
          "address",
          createInlineObjectTsType(addressProperties, true),
        ),
      ];

      const extractedTypes: ExtractedTypeInfo[] = [
        createExtractedType("UserInput", [
          createField("profile", createInlineObjectTsType(profileProperties)),
        ]),
      ];

      const input: AutoTypeGeneratorInput = {
        extractedTypes,
        resolversResult: createEmptyResolversResult(),
      };

      const result = generateAutoTypes(input);

      expect(result.autoGeneratedTypes).toHaveLength(2);

      const typeNames = result.autoGeneratedTypes.map((t) => t.name).sort();
      expect(typeNames).toEqual([
        "UserProfileAddressInput",
        "UserProfileInput",
      ]);
    });

    it("preserves defaultValue from inline object properties", () => {
      const inlineProperties: InlineObjectPropertyDef[] = [
        {
          name: "age",
          tsType: createPrimitiveTsType("number"),
          optional: false,
          description: null,
          deprecated: null,
          directives: null,
          defaultValue: { kind: "number", value: 18 },
        },
      ];

      const extractedTypes: ExtractedTypeInfo[] = [
        createExtractedType("CreateUserInput", [
          createField("profile", createInlineObjectTsType(inlineProperties)),
        ]),
      ];

      const input: AutoTypeGeneratorInput = {
        extractedTypes,
        resolversResult: createEmptyResolversResult(),
      };

      const result = generateAutoTypes(input);

      expect(result.autoGeneratedTypes).toHaveLength(1);
      const autoType = result.autoGeneratedTypes[0]!;
      expect(autoType.fields[0]!.defaultValue).toEqual({
        kind: "number",
        value: 18,
      });
    });
  });

  describe("Resolver argument inline objects", () => {
    it("generates Input Object type from Query resolver argument", () => {
      const resolversResult: ExtractResolversResult = {
        queryFields: {
          fields: [
            {
              name: "searchUsers",
              type: {
                typeName: "User",
                nullable: false,
                list: true,
                listItemNullable: false,
              },
              args: [
                {
                  name: "filter",
                  type: {
                    typeName: "__INLINE_OBJECT__",
                    nullable: false,
                    list: false,
                    listItemNullable: null,
                  },
                  description: "Search filter",
                  deprecated: null,
                  defaultValue: null,
                  inlineObjectProperties: [
                    createProperty(
                      "namePattern",
                      createPrimitiveTsType("string", true),
                    ),
                    createProperty(
                      "minAge",
                      createPrimitiveTsType("number"),
                      true,
                    ),
                  ],
                } as GraphQLInputValue & {
                  inlineObjectProperties: InlineObjectPropertyDef[];
                },
              ],
              sourceLocation: {
                file: "src/gqlkit/schema/types.ts",
                line: 1,
                column: 1,
              },
              resolverExportName: "searchUsers",
              description: null,
              deprecated: null,
              directives: null,
            },
          ],
        },
        mutationFields: { fields: [] },
        typeExtensions: [],
        diagnostics: { errors: [], warnings: [] },
      };

      const input: AutoTypeGeneratorInput = {
        extractedTypes: [],
        resolversResult,
      };

      const result = generateAutoTypes(input);

      expect(result.autoGeneratedTypes).toHaveLength(1);

      const autoType = result.autoGeneratedTypes[0]!;
      expect(autoType.name).toBe("SearchUsersFilterInput");
      expect(autoType.kind).toBe("InputObject");
      expect(autoType.generatedFrom).toEqual({
        parentTypeName: null,
        fieldPath: ["filter"],
        context: "resolverArg",
      });
    });

    it("generates Input Object type from Mutation resolver argument", () => {
      const resolversResult: ExtractResolversResult = {
        queryFields: { fields: [] },
        mutationFields: {
          fields: [
            {
              name: "createUser",
              type: {
                typeName: "User",
                nullable: false,
                list: false,
                listItemNullable: null,
              },
              args: [
                {
                  name: "data",
                  type: {
                    typeName: "__INLINE_OBJECT__",
                    nullable: false,
                    list: false,
                    listItemNullable: null,
                  },
                  description: "User data",
                  deprecated: null,
                  defaultValue: null,
                  inlineObjectProperties: [
                    createProperty("name", createPrimitiveTsType("string")),
                    createProperty(
                      "email",
                      createPrimitiveTsType("string", true),
                    ),
                  ],
                } as GraphQLInputValue & {
                  inlineObjectProperties: InlineObjectPropertyDef[];
                },
              ],
              sourceLocation: {
                file: "src/gqlkit/schema/types.ts",
                line: 1,
                column: 1,
              },
              resolverExportName: "createUser",
              description: null,
              deprecated: null,
              directives: null,
            },
          ],
        },
        typeExtensions: [],
        diagnostics: { errors: [], warnings: [] },
      };

      const input: AutoTypeGeneratorInput = {
        extractedTypes: [],
        resolversResult,
      };

      const result = generateAutoTypes(input);

      expect(result.autoGeneratedTypes).toHaveLength(1);

      const autoType = result.autoGeneratedTypes[0]!;
      expect(autoType.name).toBe("CreateUserDataInput");
      expect(autoType.kind).toBe("InputObject");
    });

    it("generates Input Object type from Field resolver argument", () => {
      const resolversResult: ExtractResolversResult = {
        queryFields: { fields: [] },
        mutationFields: { fields: [] },
        typeExtensions: [
          {
            targetTypeName: "User",
            fields: [
              {
                name: "posts",
                type: {
                  typeName: "Post",
                  nullable: false,
                  list: true,
                  listItemNullable: false,
                },
                args: [
                  {
                    name: "filter",
                    type: {
                      typeName: "__INLINE_OBJECT__",
                      nullable: true,
                      list: false,
                      listItemNullable: null,
                    },
                    description: "Filter options",
                    deprecated: null,
                    defaultValue: null,
                    inlineObjectProperties: [
                      createProperty(
                        "titlePattern",
                        createPrimitiveTsType("string", true),
                      ),
                    ],
                  } as GraphQLInputValue & {
                    inlineObjectProperties: InlineObjectPropertyDef[];
                  },
                ],
                sourceLocation: {
                  file: "src/gqlkit/schema/types.ts",
                  line: 1,
                  column: 1,
                },
                resolverExportName: "posts",
                description: null,
                deprecated: null,
                directives: null,
              },
            ],
          },
        ],
        diagnostics: { errors: [], warnings: [] },
      };

      const input: AutoTypeGeneratorInput = {
        extractedTypes: [],
        resolversResult,
      };

      const result = generateAutoTypes(input);

      expect(result.autoGeneratedTypes).toHaveLength(1);

      const autoType = result.autoGeneratedTypes[0]!;
      expect(autoType.name).toBe("UserPostsFilterInput");
      expect(autoType.kind).toBe("InputObject");
      expect(autoType.generatedFrom).toEqual({
        parentTypeName: "User",
        fieldPath: ["filter"],
        context: "resolverArg",
      });
    });

    it("generates nested Input Object types from resolver arguments", () => {
      const notificationsProperties: InlineObjectPropertyDef[] = [
        createProperty("email", createPrimitiveTsType("boolean")),
        createProperty("push", createPrimitiveTsType("boolean")),
      ];

      const settingsProperties: InlineObjectPropertyDef[] = [
        createProperty(
          "notifications",
          createInlineObjectTsType(notificationsProperties),
        ),
      ];

      const resolversResult: ExtractResolversResult = {
        queryFields: { fields: [] },
        mutationFields: {
          fields: [
            {
              name: "updateSettings",
              type: {
                typeName: "Result",
                nullable: false,
                list: false,
                listItemNullable: null,
              },
              args: [
                {
                  name: "settings",
                  type: {
                    typeName: "__INLINE_OBJECT__",
                    nullable: false,
                    list: false,
                    listItemNullable: null,
                  },
                  description: null,
                  deprecated: null,
                  defaultValue: null,
                  inlineObjectProperties: settingsProperties,
                } as GraphQLInputValue & {
                  inlineObjectProperties: InlineObjectPropertyDef[];
                },
              ],
              sourceLocation: {
                file: "src/gqlkit/schema/types.ts",
                line: 1,
                column: 1,
              },
              resolverExportName: "updateSettings",
              description: null,
              deprecated: null,
              directives: null,
            },
          ],
        },
        typeExtensions: [],
        diagnostics: { errors: [], warnings: [] },
      };

      const input: AutoTypeGeneratorInput = {
        extractedTypes: [],
        resolversResult,
      };

      const result = generateAutoTypes(input);

      expect(result.autoGeneratedTypes).toHaveLength(2);

      const typeNames = result.autoGeneratedTypes.map((t) => t.name).sort();
      expect(typeNames).toEqual([
        "UpdateSettingsSettingsInput",
        "UpdateSettingsSettingsNotificationsInput",
      ]);
    });
  });

  describe("Updated types with resolved references", () => {
    it("updates extractedTypes with resolved type references", () => {
      const inlineProperties: InlineObjectPropertyDef[] = [
        createProperty("bio", createPrimitiveTsType("string")),
      ];

      const extractedTypes: ExtractedTypeInfo[] = [
        createExtractedType("User", [
          createField("id", createPrimitiveTsType("string")),
          createField("profile", createInlineObjectTsType(inlineProperties)),
        ]),
      ];

      const input: AutoTypeGeneratorInput = {
        extractedTypes,
        resolversResult: createEmptyResolversResult(),
      };

      const result = generateAutoTypes(input);

      const updatedUser = result.updatedExtractedTypes.find(
        (t) => t.metadata.name === "User",
      );
      expect(updatedUser).toBeDefined();

      const profileField = updatedUser!.fields.find(
        (f) => f.name === "profile",
      );
      expect(profileField).toBeDefined();
      expect(profileField!.tsType.kind).toBe("reference");
      expect(profileField!.tsType.name).toBe("UserProfile");
    });

    it("updates resolversResult with resolved type references", () => {
      const resolversResult: ExtractResolversResult = {
        queryFields: {
          fields: [
            {
              name: "createUser",
              type: {
                typeName: "User",
                nullable: false,
                list: false,
                listItemNullable: null,
              },
              args: [
                {
                  name: "input",
                  type: {
                    typeName: "__INLINE_OBJECT__",
                    nullable: false,
                    list: false,
                    listItemNullable: null,
                  },
                  description: null,
                  deprecated: null,
                  defaultValue: null,
                  inlineObjectProperties: [
                    createProperty("name", createPrimitiveTsType("string")),
                  ],
                } as GraphQLInputValue & {
                  inlineObjectProperties: InlineObjectPropertyDef[];
                },
              ],
              sourceLocation: {
                file: "src/gqlkit/schema/types.ts",
                line: 1,
                column: 1,
              },
              resolverExportName: "createUser",
              description: null,
              deprecated: null,
              directives: null,
            },
          ],
        },
        mutationFields: { fields: [] },
        typeExtensions: [],
        diagnostics: { errors: [], warnings: [] },
      };

      const input: AutoTypeGeneratorInput = {
        extractedTypes: [],
        resolversResult,
      };

      const result = generateAutoTypes(input);

      const queryField = result.updatedResolversResult.queryFields.fields[0]!;
      const inputArg = queryField.args![0]!;
      expect(inputArg.type.typeName).toBe("CreateUserInputInput");
    });
  });

  describe("GeneratedFromInfo tracking", () => {
    it("tracks generation source for object field types", () => {
      const inlineProperties: InlineObjectPropertyDef[] = [
        createProperty("bio", createPrimitiveTsType("string")),
      ];

      const extractedTypes: ExtractedTypeInfo[] = [
        createExtractedType("User", [
          createField("profile", createInlineObjectTsType(inlineProperties)),
        ]),
      ];

      const input: AutoTypeGeneratorInput = {
        extractedTypes,
        resolversResult: createEmptyResolversResult(),
      };

      const result = generateAutoTypes(input);

      expect(result.autoGeneratedTypes[0]!.generatedFrom).toEqual({
        parentTypeName: "User",
        fieldPath: ["profile"],
        context: "typeField",
      });
    });

    it("tracks generation source for input field types", () => {
      const inlineProperties: InlineObjectPropertyDef[] = [
        createProperty("bio", createPrimitiveTsType("string")),
      ];

      const extractedTypes: ExtractedTypeInfo[] = [
        createExtractedType("CreateUserInput", [
          createField("profile", createInlineObjectTsType(inlineProperties)),
        ]),
      ];

      const input: AutoTypeGeneratorInput = {
        extractedTypes,
        resolversResult: createEmptyResolversResult(),
      };

      const result = generateAutoTypes(input);

      expect(result.autoGeneratedTypes[0]!.generatedFrom).toEqual({
        parentTypeName: "CreateUserInput",
        fieldPath: ["profile"],
        context: "inputField",
      });
    });
  });
});
