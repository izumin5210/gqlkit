import type {
  ExtractResolversResult,
  GraphQLFieldDefinition,
} from "../resolver-extractor/index.js";
import type {
  DirectiveArgumentValue,
  DirectiveInfo,
} from "../shared/directive-detector.js";
import type { DeprecationInfo } from "../shared/tsdoc-parser.js";
import { convertTsTypeToGraphQLType } from "../shared/type-converter.js";
import type {
  ExtractedTypeInfo,
  FieldDefinition,
  GraphQLFieldType,
  InlineObjectPropertyDef,
  SourceLocation,
  TSTypeReference,
} from "../type-extractor/types/index.js";
import {
  type AutoTypeNameContext,
  generateAutoTypeName,
} from "./naming-convention.js";

/**
 * Information about where an auto-generated type was generated from.
 */
export interface GeneratedFromInfo {
  readonly parentTypeName: string | null;
  readonly fieldPath: ReadonlyArray<string>;
  readonly context: "typeField" | "inputField" | "resolverArg";
}

/**
 * Field information for auto-generated types.
 */
export interface AutoGeneratedField {
  readonly name: string;
  readonly type: GraphQLFieldType;
  readonly description: string | null;
  readonly deprecated: DeprecationInfo | null;
  readonly directives: ReadonlyArray<DirectiveInfo> | null;
  readonly defaultValue: DirectiveArgumentValue | null;
}

/**
 * Auto-generated type information.
 */
export interface AutoGeneratedType {
  readonly name: string;
  readonly kind: "Object" | "InputObject";
  readonly fields: ReadonlyArray<AutoGeneratedField>;
  readonly sourceLocation: SourceLocation;
  readonly generatedFrom: GeneratedFromInfo;
  readonly description: string | null;
}

export interface AutoTypeGeneratorInput {
  readonly extractedTypes: ReadonlyArray<ExtractedTypeInfo>;
  readonly resolversResult: ExtractResolversResult;
}

export interface AutoTypeGeneratorResult {
  readonly autoGeneratedTypes: ReadonlyArray<AutoGeneratedType>;
  readonly updatedExtractedTypes: ReadonlyArray<ExtractedTypeInfo>;
  readonly updatedResolversResult: ExtractResolversResult;
}

interface InlineObjectWithContext {
  readonly properties: ReadonlyArray<InlineObjectPropertyDef>;
  readonly context: AutoTypeNameContext;
  readonly sourceLocation: SourceLocation;
  readonly nullable: boolean;
}


function isInputTypeName(name: string): boolean {
  return name.endsWith("Input");
}

function collectInlineObjectsFromType(
  typeInfo: ExtractedTypeInfo,
): InlineObjectWithContext[] {
  const results: InlineObjectWithContext[] = [];
  const isInput = isInputTypeName(typeInfo.metadata.name);

  for (const field of typeInfo.fields) {
    collectInlineObjectsFromField(
      field,
      typeInfo.metadata.name,
      [],
      isInput,
      typeInfo.metadata.sourceFile,
      results,
    );
  }

  return results;
}

function collectInlineObjectsFromField(
  field: FieldDefinition,
  parentTypeName: string,
  parentPath: ReadonlyArray<string>,
  isInput: boolean,
  sourceFile: string,
  results: InlineObjectWithContext[],
): void {
  const tsType = field.tsType;

  if (tsType.kind !== "inlineObject" || !tsType.inlineObjectProperties) {
    return;
  }

  const fieldPath = [...parentPath, field.name];

  const context: AutoTypeNameContext = isInput
    ? {
        kind: "inputField",
        parentTypeName,
        fieldPath,
      }
    : {
        kind: "objectField",
        parentTypeName,
        fieldPath,
      };

  results.push({
    properties: tsType.inlineObjectProperties,
    context,
    sourceLocation: { file: sourceFile, line: 1, column: 1 },
    nullable: tsType.nullable,
  });

  for (const prop of tsType.inlineObjectProperties) {
    if (
      prop.tsType.kind === "inlineObject" &&
      prop.tsType.inlineObjectProperties
    ) {
      const nestedPath = [...fieldPath, prop.name];
      const nestedContext: AutoTypeNameContext = isInput
        ? {
            kind: "inputField",
            parentTypeName,
            fieldPath: nestedPath,
          }
        : {
            kind: "objectField",
            parentTypeName,
            fieldPath: nestedPath,
          };

      collectNestedInlineObjects(
        prop.tsType.inlineObjectProperties,
        nestedContext,
        nestedPath,
        parentTypeName,
        isInput,
        sourceFile,
        results,
      );
    }
  }
}

function collectNestedInlineObjects(
  properties: ReadonlyArray<InlineObjectPropertyDef>,
  context: AutoTypeNameContext,
  currentPath: ReadonlyArray<string>,
  parentTypeName: string,
  isInput: boolean,
  sourceFile: string,
  results: InlineObjectWithContext[],
): void {
  results.push({
    properties,
    context,
    sourceLocation: { file: sourceFile, line: 1, column: 1 },
    nullable: false,
  });

  for (const prop of properties) {
    if (
      prop.tsType.kind === "inlineObject" &&
      prop.tsType.inlineObjectProperties
    ) {
      const nestedPath = [...currentPath, prop.name];
      const nestedContext: AutoTypeNameContext = isInput
        ? {
            kind: "inputField",
            parentTypeName,
            fieldPath: nestedPath,
          }
        : {
            kind: "objectField",
            parentTypeName,
            fieldPath: nestedPath,
          };

      collectNestedInlineObjects(
        prop.tsType.inlineObjectProperties,
        nestedContext,
        nestedPath,
        parentTypeName,
        isInput,
        sourceFile,
        results,
      );
    }
  }
}

function collectInlineObjectsFromResolvers(
  resolversResult: ExtractResolversResult,
): InlineObjectWithContext[] {
  const results: InlineObjectWithContext[] = [];

  for (const field of resolversResult.queryFields.fields) {
    collectInlineObjectsFromResolverArgs(field, "query", null, results);
  }

  for (const field of resolversResult.mutationFields.fields) {
    collectInlineObjectsFromResolverArgs(field, "mutation", null, results);
  }

  for (const ext of resolversResult.typeExtensions) {
    for (const field of ext.fields) {
      collectInlineObjectsFromResolverArgs(
        field,
        "field",
        ext.targetTypeName,
        results,
      );
    }
  }

  return results;
}

function collectInlineObjectsFromResolverArgs(
  field: GraphQLFieldDefinition,
  resolverType: "query" | "mutation" | "field",
  parentTypeName: string | null,
  results: InlineObjectWithContext[],
): void {
  if (!field.args) return;

  for (const arg of field.args) {
    const extendedArg = arg;
    if (!extendedArg.inlineObjectProperties) continue;

    const context: AutoTypeNameContext = {
      kind: "resolverArg",
      resolverType,
      fieldName: field.name,
      argName: arg.name,
      parentTypeName,
      fieldPath: [],
    };

    results.push({
      properties: extendedArg.inlineObjectProperties,
      context,
      sourceLocation: field.sourceLocation,
      nullable: arg.type.nullable,
    });

    collectNestedInlineObjectsFromArg(
      extendedArg.inlineObjectProperties,
      resolverType,
      field.name,
      arg.name,
      parentTypeName,
      [],
      field.sourceLocation,
      results,
    );
  }
}

function collectNestedInlineObjectsFromArg(
  properties: ReadonlyArray<InlineObjectPropertyDef>,
  resolverType: "query" | "mutation" | "field",
  fieldName: string,
  argName: string,
  parentTypeName: string | null,
  currentPath: ReadonlyArray<string>,
  sourceLocation: SourceLocation,
  results: InlineObjectWithContext[],
): void {
  for (const prop of properties) {
    if (
      prop.tsType.kind === "inlineObject" &&
      prop.tsType.inlineObjectProperties
    ) {
      const nestedPath = [...currentPath, prop.name];
      const nestedContext: AutoTypeNameContext = {
        kind: "resolverArg",
        resolverType,
        fieldName,
        argName,
        parentTypeName,
        fieldPath: nestedPath,
      };

      results.push({
        properties: prop.tsType.inlineObjectProperties,
        context: nestedContext,
        sourceLocation,
        nullable: prop.tsType.nullable,
      });

      collectNestedInlineObjectsFromArg(
        prop.tsType.inlineObjectProperties,
        resolverType,
        fieldName,
        argName,
        parentTypeName,
        nestedPath,
        sourceLocation,
        results,
      );
    }
  }
}

function generateAutoType(
  inlineObj: InlineObjectWithContext,
  generatedTypeNames: Map<string, string>,
): AutoGeneratedType {
  const name = generateAutoTypeName(inlineObj.context);
  const isInput =
    inlineObj.context.kind === "inputField" ||
    inlineObj.context.kind === "resolverArg";

  const fields: AutoGeneratedField[] = inlineObj.properties.map((prop) => {
    const fieldType = resolveFieldType(prop, generatedTypeNames);
    return {
      name: prop.name,
      type: fieldType,
      description: prop.description,
      deprecated: prop.deprecated,
      directives: prop.directives,
      defaultValue: prop.defaultValue,
    };
  });

  const generatedFrom: GeneratedFromInfo = {
    parentTypeName:
      inlineObj.context.kind === "resolverArg"
        ? inlineObj.context.parentTypeName
        : inlineObj.context.parentTypeName,
    fieldPath:
      inlineObj.context.kind === "resolverArg" &&
      inlineObj.context.fieldPath.length === 0
        ? [inlineObj.context.argName]
        : inlineObj.context.fieldPath,
    context:
      inlineObj.context.kind === "objectField"
        ? "typeField"
        : inlineObj.context.kind === "inputField"
          ? "inputField"
          : "resolverArg",
  };

  return {
    name,
    kind: isInput ? "InputObject" : "Object",
    fields,
    sourceLocation: inlineObj.sourceLocation,
    generatedFrom,
    description: null,
  };
}

function resolveFieldType(
  prop: InlineObjectPropertyDef,
  generatedTypeNames: Map<string, string>,
): GraphQLFieldType {
  if (
    prop.tsType.kind === "inlineObject" &&
    prop.tsType.inlineObjectProperties
  ) {
    const propsKey = getPropertiesKey(prop.tsType.inlineObjectProperties);
    const resolvedTypeName = generatedTypeNames.get(propsKey);
    if (resolvedTypeName) {
      return {
        typeName: resolvedTypeName,
        nullable: prop.tsType.nullable || prop.optional,
        list: false,
        listItemNullable: null,
      };
    }
  }

  return convertTsTypeToGraphQLType(prop.tsType, prop.optional);
}

function getPropertiesKey(
  properties: ReadonlyArray<InlineObjectPropertyDef>,
): string {
  return properties.map((p) => `${p.name}:${getTypeKey(p.tsType)}`).join("|");
}

function getTypeKey(tsType: TSTypeReference): string {
  if (tsType.kind === "inlineObject" && tsType.inlineObjectProperties) {
    return `inline(${getPropertiesKey(tsType.inlineObjectProperties)})`;
  }
  return `${tsType.kind}:${tsType.name ?? ""}`;
}

function updateExtractedTypes(
  extractedTypes: ReadonlyArray<ExtractedTypeInfo>,
  generatedTypeNames: Map<string, string>,
): ExtractedTypeInfo[] {
  return extractedTypes.map((typeInfo) => ({
    ...typeInfo,
    fields: typeInfo.fields.map((field) =>
      updateField(field, generatedTypeNames),
    ),
  }));
}

function updateField(
  field: FieldDefinition,
  generatedTypeNames: Map<string, string>,
): FieldDefinition {
  if (
    field.tsType.kind === "inlineObject" &&
    field.tsType.inlineObjectProperties
  ) {
    const propsKey = getPropertiesKey(field.tsType.inlineObjectProperties);
    const resolvedTypeName = generatedTypeNames.get(propsKey);
    if (resolvedTypeName) {
      return {
        ...field,
        tsType: {
          kind: "reference",
          name: resolvedTypeName,
          elementType: null,
          members: null,
          nullable: field.tsType.nullable,
          scalarInfo: null,
          inlineObjectProperties: null,
        },
      };
    }
  }
  return field;
}

function updateResolversResult(
  resolversResult: ExtractResolversResult,
  generatedTypeNames: Map<string, string>,
): ExtractResolversResult {
  return {
    ...resolversResult,
    queryFields: {
      fields: resolversResult.queryFields.fields.map((field) =>
        updateResolverField(field, generatedTypeNames),
      ),
    },
    mutationFields: {
      fields: resolversResult.mutationFields.fields.map((field) =>
        updateResolverField(field, generatedTypeNames),
      ),
    },
    typeExtensions: resolversResult.typeExtensions.map((ext) => ({
      ...ext,
      fields: ext.fields.map((field) =>
        updateResolverField(field, generatedTypeNames),
      ),
    })),
  };
}

function updateResolverField(
  field: GraphQLFieldDefinition,
  generatedTypeNames: Map<string, string>,
): GraphQLFieldDefinition {
  if (!field.args) return field;

  const updatedArgs = field.args.map((arg) => {
    const extendedArg = arg;
    if (!extendedArg.inlineObjectProperties) return arg;

    const propsKey = getPropertiesKey(extendedArg.inlineObjectProperties);
    const resolvedTypeName = generatedTypeNames.get(propsKey);

    if (resolvedTypeName) {
      return {
        ...arg,
        type: {
          ...arg.type,
          typeName: resolvedTypeName,
        },
      };
    }
    return arg;
  });

  return {
    ...field,
    args: updatedArgs,
  };
}

function buildGeneratedTypeNamesMap(
  inlineObjects: InlineObjectWithContext[],
): Map<string, string> {
  const map = new Map<string, string>();

  for (const inlineObj of inlineObjects) {
    const typeName = generateAutoTypeName(inlineObj.context);
    const propsKey = getPropertiesKey(inlineObj.properties);
    map.set(propsKey, typeName);
  }

  return map;
}

export function generateAutoTypes(
  input: AutoTypeGeneratorInput,
): AutoTypeGeneratorResult {
  const inlineObjectsFromTypes: InlineObjectWithContext[] = [];
  for (const typeInfo of input.extractedTypes) {
    inlineObjectsFromTypes.push(...collectInlineObjectsFromType(typeInfo));
  }

  const inlineObjectsFromResolvers = collectInlineObjectsFromResolvers(
    input.resolversResult,
  );

  const allInlineObjects = [
    ...inlineObjectsFromTypes,
    ...inlineObjectsFromResolvers,
  ];

  const generatedTypeNames = buildGeneratedTypeNamesMap(allInlineObjects);

  const autoGeneratedTypes: AutoGeneratedType[] = allInlineObjects.map(
    (inlineObj) => generateAutoType(inlineObj, generatedTypeNames),
  );

  const updatedExtractedTypes = updateExtractedTypes(
    input.extractedTypes,
    generatedTypeNames,
  );

  const updatedResolversResult = updateResolversResult(
    input.resolversResult,
    generatedTypeNames,
  );

  return {
    autoGeneratedTypes,
    updatedExtractedTypes,
    updatedResolversResult,
  };
}
