import path from "node:path";
import { toPosixPath } from "../../shared/index.js";
import type { CollectedScalarType } from "../../type-extractor/collector/scalar-collector.js";
import {
  type BuildDocumentOptions,
  buildDocumentNode,
} from "../builder/ast-builder.js";
import type { IntegratedResult } from "../integrator/result-integrator.js";
import type { ResolverInfo } from "../resolver-collector/resolver-collector.js";

const GENERATED_FILE_HEADER =
  "// This file is auto-generated by gqlkit. DO NOT EDIT.";

function formatDocumentNodeAsCode(
  integratedResult: IntegratedResult,
  options?: BuildDocumentOptions,
): string {
  const doc = buildDocumentNode(integratedResult, options);

  return JSON.stringify(doc, null, 2);
}

export function emitTypeDefsCode(
  integratedResult: IntegratedResult,
  options?: BuildDocumentOptions,
): string {
  const documentNodeCode = formatDocumentNodeAsCode(integratedResult, options);

  return `${GENERATED_FILE_HEADER}

import type { DocumentNode } from "graphql";

export const typeDefs: DocumentNode = ${documentNodeCode} as DocumentNode;
`;
}

function computeRelativeImportPath(fromDir: string, toFile: string): string {
  const relativePath = toPosixPath(path.relative(fromDir, toFile));
  const withoutExt = relativePath.replace(/\.ts$/, ".js");
  if (!withoutExt.startsWith(".")) {
    return `./${withoutExt}`;
  }
  return withoutExt;
}

interface ScalarTypeImport {
  readonly typeName: string;
  readonly sourceFile: string;
}

function collectScalarTypeImports(
  customScalars: ReadonlyArray<CollectedScalarType>,
): ScalarTypeImport[] {
  const imports: ScalarTypeImport[] = [];
  const seen = new Set<string>();

  for (const scalar of customScalars) {
    if (scalar.inputType && !seen.has(scalar.inputType.typeName)) {
      imports.push({
        typeName: scalar.inputType.typeName,
        sourceFile: scalar.inputType.sourceFile,
      });
      seen.add(scalar.inputType.typeName);
    }

    for (const outputType of scalar.outputTypes) {
      if (!seen.has(outputType.typeName)) {
        imports.push({
          typeName: outputType.typeName,
          sourceFile: outputType.sourceFile,
        });
        seen.add(outputType.typeName);
      }
    }
  }

  return imports;
}

function buildScalarTypeImports(
  scalarTypeImports: ScalarTypeImport[],
  outputDir: string,
): string[] {
  const importsByFile = new Map<string, string[]>();

  for (const imp of scalarTypeImports) {
    const existing = importsByFile.get(imp.sourceFile) ?? [];
    existing.push(imp.typeName);
    importsByFile.set(imp.sourceFile, existing);
  }

  const imports: string[] = [];
  const sortedFiles = [...importsByFile.keys()].sort();

  for (const sourceFile of sortedFiles) {
    const typeNames = importsByFile.get(sourceFile) ?? [];
    const importPath = computeRelativeImportPath(outputDir, sourceFile);
    imports.push(
      `import type { ${typeNames.sort().join(", ")} } from "${importPath}";`,
    );
  }

  return imports;
}

function buildScalarTypeParameter(scalar: CollectedScalarType): string {
  const inputTypeName = scalar.inputType?.typeName ?? "unknown";
  const outputTypeNames = scalar.outputTypes.map((t) => t.typeName);
  const outputTypeUnion = outputTypeNames.join(" | ");
  return `GraphQLScalarType<${inputTypeName}, ${outputTypeUnion}>`;
}

function buildScalarsArgumentType(
  customScalars: ReadonlyArray<CollectedScalarType>,
): string {
  const entries = customScalars
    .map((scalar) => {
      const typeParam = buildScalarTypeParameter(scalar);
      return `    ${scalar.scalarName}: ${typeParam};`;
    })
    .join("\n");

  return `{\n  scalars: {\n${entries}\n  };\n}`;
}

function buildScalarResolverEntries(
  customScalars: ReadonlyArray<CollectedScalarType>,
): string[] {
  return customScalars.map(
    (scalar) => `    ${scalar.scalarName}: scalars.${scalar.scalarName},`,
  );
}

export function emitResolversCode(
  resolverInfo: ResolverInfo,
  outputDir: string,
  customScalars: ReadonlyArray<CollectedScalarType> = [],
): string {
  const hasCustomScalars = customScalars.length > 0;
  const imports: string[] = [];
  const importedValues = new Set<string>();

  // Add GraphQLScalarType import if we have custom scalars
  if (hasCustomScalars) {
    imports.push('import { GraphQLScalarType } from "graphql";');
  }

  // Add resolver imports
  for (const sourceFile of resolverInfo.sourceFiles) {
    const resolverValueNames = new Set<string>();

    for (const type of resolverInfo.types) {
      for (const field of type.fields) {
        if (field.sourceFile === sourceFile) {
          resolverValueNames.add(field.resolverValueName);
        }
      }
    }

    const importPath = computeRelativeImportPath(outputDir, sourceFile);
    const uniqueValues = [...resolverValueNames].filter(
      (v) => !importedValues.has(v),
    );

    if (uniqueValues.length > 0) {
      imports.push(
        `import { ${uniqueValues.sort().join(", ")} } from "${importPath}";`,
      );
      for (const v of uniqueValues) {
        importedValues.add(v);
      }
    }
  }

  // Add scalar type imports
  if (hasCustomScalars) {
    const scalarTypeImports = collectScalarTypeImports(customScalars);
    const scalarImports = buildScalarTypeImports(scalarTypeImports, outputDir);
    imports.push(...scalarImports);
  }

  // Build resolver entries for Query/Mutation/etc
  const typeEntries: string[] = [];

  // Add scalar resolver entries first if we have custom scalars
  if (hasCustomScalars) {
    typeEntries.push(...buildScalarResolverEntries(customScalars));
  }

  for (const type of resolverInfo.types) {
    const fieldEntries = type.fields.map((field) => {
      if (field.isDirectExport) {
        return `      ${field.fieldName}: ${field.resolverValueName},`;
      }
      return `      ${field.fieldName}: ${field.resolverValueName}.${field.fieldName},`;
    });
    typeEntries.push(
      `    ${type.typeName}: {\n${fieldEntries.join("\n")}\n    },`,
    );
  }

  // Build function signature
  const functionSignature = hasCustomScalars
    ? `export function createResolvers({ scalars }: ${buildScalarsArgumentType(customScalars)})`
    : "export function createResolvers()";

  return `${GENERATED_FILE_HEADER}

${imports.join("\n")}

${functionSignature} {
  return {
${typeEntries.join("\n")}
  };
}
`;
}
