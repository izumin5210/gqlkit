import path from "node:path";
import { toPosixPath } from "../../shared/index.js";
import {
  type BuildDocumentOptions,
  buildDocumentNode,
} from "../builder/ast-builder.js";
import type { IntegratedResult } from "../integrator/result-integrator.js";
import type {
  CustomScalarInfo,
  ResolverInfo,
} from "../resolver-collector/resolver-collector.js";

const GENERATED_FILE_HEADER =
  "// This file is auto-generated by gqlkit. DO NOT EDIT.";

function formatDocumentNodeAsCode(
  integratedResult: IntegratedResult,
  options?: BuildDocumentOptions,
): string {
  const doc = buildDocumentNode(integratedResult, options);

  return JSON.stringify(doc, null, 2);
}

export function emitTypeDefsCode(
  integratedResult: IntegratedResult,
  options?: BuildDocumentOptions,
): string {
  const documentNodeCode = formatDocumentNodeAsCode(integratedResult, options);

  return `${GENERATED_FILE_HEADER}

import type { DocumentNode } from "graphql";

export const typeDefs: DocumentNode = ${documentNodeCode} as DocumentNode;
`;
}

function computeRelativeImportPath(fromDir: string, toFile: string): string {
  const relativePath = toPosixPath(path.relative(fromDir, toFile));
  const withoutExt = relativePath.replace(/\.ts$/, ".js");
  if (!withoutExt.startsWith(".")) {
    return `./${withoutExt}`;
  }
  return withoutExt;
}

function buildScalarTypeImports(
  customScalars: ReadonlyArray<CustomScalarInfo>,
  outputDir: string,
): string[] {
  const typeImports: string[] = [];
  const importsByPath = new Map<string, Set<string>>();

  for (const scalar of customScalars) {
    if (scalar.typeImportPath !== null) {
      const importPath = computeRelativeImportPath(
        outputDir,
        scalar.typeImportPath,
      );
      const existing = importsByPath.get(importPath) ?? new Set();
      existing.add(scalar.inputTypeName);
      if (scalar.outputTypeName !== scalar.inputTypeName) {
        existing.add(scalar.outputTypeName);
      }
      importsByPath.set(importPath, existing);
    }
  }

  for (const [importPath, types] of importsByPath) {
    const sortedTypes = [...types].sort();
    typeImports.push(
      `import type { ${sortedTypes.join(", ")} } from "${importPath}";`,
    );
  }

  return typeImports;
}

function buildScalarTypeSignature(scalar: CustomScalarInfo): string {
  if (scalar.inputTypeName === scalar.outputTypeName) {
    return `GraphQLScalarType<${scalar.inputTypeName}, ${scalar.inputTypeName}>`;
  }
  return `GraphQLScalarType<${scalar.inputTypeName}, ${scalar.outputTypeName}>`;
}

export function emitResolversCode(
  resolverInfo: ResolverInfo,
  outputDir: string,
): string {
  const imports: string[] = [];
  const importedValues = new Set<string>();
  const hasCustomScalars = resolverInfo.customScalars.length > 0;

  if (hasCustomScalars) {
    imports.push('import type { GraphQLScalarType } from "graphql";');
    const scalarTypeImports = buildScalarTypeImports(
      resolverInfo.customScalars,
      outputDir,
    );
    imports.push(...scalarTypeImports);
  }

  for (const sourceFile of resolverInfo.sourceFiles) {
    const resolverValueNames = new Set<string>();

    for (const type of resolverInfo.types) {
      for (const field of type.fields) {
        if (field.sourceFile === sourceFile) {
          resolverValueNames.add(field.resolverValueName);
        }
      }
    }

    const importPath = computeRelativeImportPath(outputDir, sourceFile);
    const uniqueValues = [...resolverValueNames].filter(
      (v) => !importedValues.has(v),
    );

    if (uniqueValues.length > 0) {
      imports.push(
        `import { ${uniqueValues.sort().join(", ")} } from "${importPath}";`,
      );
      for (const v of uniqueValues) {
        importedValues.add(v);
      }
    }
  }

  const typeEntries: string[] = [];

  for (const scalar of resolverInfo.customScalars) {
    typeEntries.push(`    ${scalar.scalarName}: scalars.${scalar.scalarName},`);
  }

  for (const type of resolverInfo.types) {
    const fieldEntries = type.fields.map((field) => {
      if (field.isDirectExport) {
        return `      ${field.fieldName}: ${field.resolverValueName},`;
      }
      return `      ${field.fieldName}: ${field.resolverValueName}.${field.fieldName},`;
    });
    typeEntries.push(
      `    ${type.typeName}: {\n${fieldEntries.join("\n")}\n    },`,
    );
  }

  if (hasCustomScalars) {
    return emitCreateResolversFunction(
      imports,
      typeEntries,
      resolverInfo.customScalars,
      resolverInfo.types,
    );
  }

  return emitCreateResolversFunctionNoScalars(
    imports,
    typeEntries,
    resolverInfo.types,
  );
}

function emitCreateResolversFunction(
  imports: string[],
  typeEntries: string[],
  customScalars: ReadonlyArray<CustomScalarInfo>,
  types: ReadonlyArray<{
    typeName: string;
    fields: ReadonlyArray<{
      fieldName: string;
      resolverValueName: string;
      isDirectExport: boolean;
    }>;
  }>,
): string {
  const scalarsParamEntries = customScalars.map(
    (s) => `    ${s.scalarName}: ${buildScalarTypeSignature(s)};`,
  );

  const returnTypeScalarEntries = customScalars.map(
    (s) => `  ${s.scalarName}: ${buildScalarTypeSignature(s)};`,
  );

  const returnTypeTypeEntries = types.map((type) => {
    const fieldTypes = type.fields.map(
      (f) =>
        `    ${f.fieldName}: typeof ${f.isDirectExport ? f.resolverValueName : `${f.resolverValueName}.${f.fieldName}`};`,
    );
    return `  ${type.typeName}: {\n${fieldTypes.join("\n")}\n  };`;
  });

  return `${GENERATED_FILE_HEADER}

${imports.join("\n")}

export function createResolvers({ scalars }: {
  scalars: {
${scalarsParamEntries.join("\n")}
  };
}): {
${returnTypeScalarEntries.join("\n")}
${returnTypeTypeEntries.join("\n")}
} {
  return {
${typeEntries.join("\n")}
  };
}
`;
}

function emitCreateResolversFunctionNoScalars(
  imports: string[],
  typeEntries: string[],
  types: ReadonlyArray<{
    typeName: string;
    fields: ReadonlyArray<{
      fieldName: string;
      resolverValueName: string;
      isDirectExport: boolean;
    }>;
  }>,
): string {
  const returnTypeEntries = types.map((type) => {
    const fieldTypes = type.fields.map(
      (f) =>
        `    ${f.fieldName}: typeof ${f.isDirectExport ? f.resolverValueName : `${f.resolverValueName}.${f.fieldName}`};`,
    );
    return `  ${type.typeName}: {\n${fieldTypes.join("\n")}\n  };`;
  });

  return `${GENERATED_FILE_HEADER}

${imports.join("\n")}

export function createResolvers(): {
${returnTypeEntries.join("\n")}
} {
  return {
${typeEntries.join("\n")}
  };
}
`;
}
