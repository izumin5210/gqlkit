# Test Case Structure and Conventions

Detailed documentation of golden test case structure for gqlkit.

## Directory Structure

```
packages/cli/src/gen-orchestrator/testdata/
└── {test-case-name}/
    ├── tsconfig.json               # TypeScript configuration
    └── src/
        └── gqlkit/
            ├── schema/             # Source files (input)
            │   ├── query.ts        # Query resolvers
            │   ├── mutation.ts     # Mutation resolvers (if any)
            │   └── *.ts            # Type definitions and field resolvers
            └── __generated__/      # Golden files (expected output)
                ├── diagnostics.json
                ├── resolvers.ts
                ├── schema.graphql
                └── typeDefs.ts
```

## File Descriptions

### tsconfig.json

Standard TypeScript configuration for the test case:

```json
{
  "compilerOptions": {
    "module": "esnext",
    "moduleResolution": "bundler",
    "target": "esnext",
    "strict": true,
    "noEmit": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*.ts"]
}
```

### src/gqlkit/schema/*.ts (Source Files)

TypeScript files containing:

1. **Type definitions**: Interfaces and types that become GraphQL types
2. **Resolver definitions**: Functions that become GraphQL resolvers

Example structure:
```typescript
// types.ts - Type definitions
export interface User {
  id: string;
  name: string;
  email: string | null;
}

// query.ts - Query resolvers
import { createGqlkitApis, type NoArgs } from "@gqlkit-ts/runtime";
import type { User } from "./types";

type Context = unknown;
const { defineQuery } = createGqlkitApis<Context>();

export const users = defineQuery<NoArgs, User[]>(() => []);
```

### __generated__/diagnostics.json

Array of diagnostic messages. Empty array for success cases:

```json
[]
```

For error cases:
```json
[
  {
    "code": "ERROR_CODE",
    "message": "Error description",
    "severity": "error",
    "location": {
      "file": "src/gqlkit/schema/file.ts",
      "line": 10,
      "column": 5
    }
  }
]
```

### __generated__/resolvers.ts

Generated resolver map aggregating all defined resolvers:

```typescript
import * as queryResolvers from "../schema/query";

export const resolvers = {
  Query: {
    users: queryResolvers.users,
    user: queryResolvers.user,
  },
};
```

### __generated__/schema.graphql

Human-readable GraphQL schema (for documentation/debugging):

```graphql
# This file is auto-generated by gqlkit. DO NOT EDIT.

type Query

"""Defined in: src/gqlkit/schema/types.ts"""
type User {
  email: String
  id: String!
  name: String!
}

extend type Query {
  """Defined in: src/gqlkit/schema/query.ts"""
  user(id: String!): User
  """Defined in: src/gqlkit/schema/query.ts"""
  users: [User!]!
}
```

### __generated__/typeDefs.ts

GraphQL AST as TypeScript code (for runtime usage):

```typescript
import { Kind, type DocumentNode } from "graphql";

export const typeDefs: DocumentNode = {
  kind: Kind.DOCUMENT,
  definitions: [
    // ... AST nodes
  ],
};
```

## Naming Conventions

### Test Case Names

Format: `{category}-{feature}[-{variant}]`

| Pattern | Example | Description |
|---------|---------|-------------|
| `{category}-basic` | `interface-basic` | Basic feature usage |
| `{category}-{feature}` | `directive-deprecated` | Specific feature |
| `{category}-{feature}-{variant}` | `scalar-config-global-type` | Feature variant |
| `{feature}-errors` | `directive-errors` | Error cases |

### Source File Names

| File | Purpose |
|------|---------|
| `query.ts` | Query resolver definitions |
| `mutation.ts` | Mutation resolver definitions |
| `types.ts` | Shared type definitions |
| `{type}.ts` | Type-specific definitions (e.g., `user.ts`) |

## Test Categories

### Normal Cases (Success)

Test cases where generation succeeds:
- diagnostics.json contains `[]`
- schema.graphql contains valid schema
- resolvers.ts contains valid resolver map

### Error Cases

Test cases where generation produces errors:
- diagnostics.json contains error array
- schema.graphql may be empty or partial
- resolvers.ts may be empty or partial

Error case naming patterns:
- `*-errors` (e.g., `directive-errors`)
- `*-invalid` (e.g., `invalid-tsconfig`)
- `*-missing-*` (e.g., `interface-missing-field`)

## Golden File Update Process

To update golden files after implementation changes:

```bash
UPDATE_GOLDEN=true pnpm test -- packages/cli/src/gen-orchestrator/golden.test.ts
```

This regenerates all `__generated__/` files based on current implementation.

## Adding New Test Cases

1. Create directory: `testdata/{test-case-name}/`
2. Add `tsconfig.json` (copy from existing case)
3. Create `src/gqlkit/schema/` with source files
4. Run test to generate golden files:
   ```bash
   UPDATE_GOLDEN=true pnpm test -- packages/cli/src/gen-orchestrator/golden.test.ts
   ```
5. Verify generated files are correct
6. Commit all files

## Best Practices

1. **Minimal source**: Include only code necessary to test the feature
2. **Clear naming**: Name should immediately convey what's being tested
3. **One feature per case**: Don't combine unrelated features
4. **Cover edge cases**: Include separate cases for error conditions
5. **Verify manually**: After generation, review golden files for correctness
